/*
 * STM32F411 — USB HID Keyboard Device (Register-Level, verbose style)
 * -------------------------------------------------------------------
 * - Pure register access (no HAL/Cube)
 * - Enumerates as a HID keyboard
 * - EP0: Control (64 bytes)
 * - EP1: Interrupt IN (8 bytes), TX FIFO #1
 * - Sends key 'a' via usb_hid_send_demo_key_a(); release with usb_hid_send_key_release()
 *
 * Requirements:
 *   - System clock configured; USB clock = 48 MHz (e.g., VCO=384 MHz, PLLQ=8)
 *   - PA11 = USB_DM, PA12 = USB_DP (AF10, very high speed)
 *   - VBUS sensing disabled (self-powered style)
 */

#include "stm32f4xx.h"
#include <stdint.h>

// ============================
// USB core register shortcuts
// ============================

#define USBx                USB_OTG_FS
#define USBx_DEVICE         ((USB_OTG_DeviceTypeDef *)(USB_OTG_FS_PERIPH_BASE + USB_OTG_DEVICE_BASE))
#define USBx_INEP(i)        ((USB_OTG_INEndpointTypeDef *)(USB_OTG_FS_PERIPH_BASE + USB_OTG_IN_ENDPOINT_BASE  + ((i) * 0x20UL)))
#define USBx_OUTEP(i)       ((USB_OTG_OUTEndpointTypeDef*)(USB_OTG_FS_PERIPH_BASE + USB_OTG_OUT_ENDPOINT_BASE + ((i) * 0x20UL)))

// ============================
// Endpoint constants
// ============================

#define EP0_MPS             (64UL)     // EP0 max packet size (control) // error
#define EP1_MPS             (8UL)      // HID report size
#define EP1_IN_ADDR         (0x81UL)   // bEndpointAddress (IN | #1)
#define EP1_TX_FIFO_NUM     (1UL)      // use dedicated TX FIFO #1 for EP1 IN

// ============================
// Internal state
// ============================

static uint8_t  ep0_setup[8];
static uint8_t  usb_address_pending = 0U;
static uint8_t  configured = 0U;

// ============================
// Descriptors (HID keyboard)
// ============================

// Device descriptor
static const uint8_t dev_desc[] = {
    18, 1,                      // bLength, bDescriptorType (DEVICE)
    0x00, 0x02,                 // bcdUSB 2.00
    0x00,                       // bDeviceClass (defined in interface)
    0x00,                       // bDeviceSubClass
    0x00,                       // bDeviceProtocol
    64,                         // bMaxPacketSize0
    0x83, 0x04,                 // idVendor  (0x0483, example)
    0x40, 0x57,                 // idProduct (0x5740, example)
    0x00, 0x01,                 // bcdDevice 1.00
    1,                          // iManufacturer
    2,                          // iProduct
    3,                          // iSerialNumber
    1                           // bNumConfigurations
};

// HID report descriptor (8-byte keyboard report)
static const uint8_t hid_report_desc[] = {
    0x05,0x01, 0x09,0x06, 0xA1,0x01,
    0x05,0x07, 0x19,0xE0, 0x29,0xE7,
    0x15,0x00, 0x25,0x01, 0x75,0x01, 0x95,0x08, 0x81,0x02,
    0x95,0x01, 0x75,0x08, 0x81,0x03,
    0x95,0x06, 0x75,0x08, 0x15,0x00, 0x25,0x65,
    0x05,0x07, 0x19,0x00, 0x29,0x65, 0x81,0x00,
    0xC0
};

// Configuration = {Configuration, Interface, HID, Endpoint}
static const uint8_t cfg_desc[] = {
    // Configuration
    9, 2,                          // bLength, bDescriptorType (CONFIGURATION)
    9+9+9+7, 0x00,                 // wTotalLength = 34
    0x01,                          // bNumInterfaces
    0x01,                          // bConfigurationValue
    0x00,                          // iConfiguration
    0xA0,                          // bmAttributes (Bus powered + Remote Wakeup)
    50,                            // bMaxPower (100 mA)

    // Interface 0 (HID Keyboard)
    9, 4,                          // bLength, bDescriptorType (INTERFACE)
    0x00,                          // bInterfaceNumber
    0x00,                          // bAlternateSetting
    0x01,                          // bNumEndpoints (1 IN)
    0x03,                          // bInterfaceClass (HID)
    0x01,                          // bInterfaceSubClass (Boot)
    0x01,                          // bInterfaceProtocol (Keyboard)
    0x00,                          // iInterface

    // HID descriptor
    9, 0x21,                       // bLength, bDescriptorType (HID)
    0x11, 0x01,                    // bcdHID 1.11
    0x00,                          // bCountryCode
    0x01,                          // bNumDescriptors
    0x22,                          // bDescriptorType (Report)
    (uint8_t)sizeof(hid_report_desc), (uint8_t)(sizeof(hid_report_desc) >> 8), // wDescriptorLength

    // Endpoint 1 IN (Interrupt)
    7, 5,                          // bLength, bDescriptorType (ENDPOINT)
    (uint8_t)EP1_IN_ADDR,          // bEndpointAddress
    0x03,                          // bmAttributes (Interrupt)
    (uint8_t)EP1_MPS, 0x00,        // wMaxPacketSize
    10                             // bInterval (10 ms)
};

// Strings (UTF-16LE)
static const uint8_t lang_str[] = { 4, 3, 0x09, 0x04 };
static const uint8_t mfg_str[]  = { 18,3,'O',0,'p',0,'e',0,'n',0,'A',0,'I',0 };
static const uint8_t prod_str[] = { 22,3,'H',0,'I',0,'D',0,' ',0,'K',0,'e',0,'y',0 };
static const uint8_t sn_str[]   = { 10,3,'0',0,'0',0,'1',0 };

// ============================
// Helper: write a packet into TX FIFO of EP n (len in bytes)
// ============================

static inline void usb_write_fifo(uint32_t ep, const uint8_t *buf, uint16_t len)
{
    volatile uint32_t *fifo = (volatile uint32_t *)(USB_OTG_FIFO_BASE + USB_OTG_FS_PERIPH_BASE + (ep * 0x1000UL));
    uint32_t words = (len + 3U) / 4U;
    for (uint32_t i = 0UL; i < words; i++) {
        uint32_t w = 0UL;
        uint32_t idx = i * 4UL;
        if (idx + 0UL < len) w |= (uint32_t)buf[idx + 0UL] << 0;
        if (idx + 1UL < len) w |= (uint32_t)buf[idx + 1UL] << 8;
        if (idx + 2UL < len) w |= (uint32_t)buf[idx + 2UL] << 16;
        if (idx + 3UL < len) w |= (uint32_t)buf[idx + 3UL] << 24;
        *fifo = w;
    }
}

// ============================
// USB GPIO + core init
// ============================

static void usb_gpio_init(void)
{
    // Enable GPIOA clock
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;

    // PA11 (DM), PA12 (DP) → AF10, very high speed, no pull
    GPIOA->MODER   &= ~((3UL << (11UL*2UL)) | (3UL << (12UL*2UL)));
    GPIOA->MODER   |=  ((2UL << (11UL*2UL)) | (2UL << (12UL*2UL)));  // AF
    GPIOA->AFR[1]  &= ~((0xFUL << ((11UL-8UL)*4UL)) | (0xFUL << ((12UL-8UL)*4UL)));
    GPIOA->AFR[1]  |=  ((10UL  << ((11UL-8UL)*4UL)) | (10UL  << ((12UL-8UL)*4UL))); // AF10
    GPIOA->OSPEEDR |=  ((3UL << (11UL*2UL)) | (3UL << (12UL*2UL)));  // very high
}

void usb_device_init(void)
{
    // Enable USB OTG FS clock
    RCC->AHB2ENR |= RCC_AHB2ENR_OTGFSEN;

    // GPIO config for DM/DP
    usb_gpio_init();

    // Core soft reset
    USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
    while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) != 0UL);

    // Select FS PHY and power up the transceiver
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL; // PHYSEL: Full speed serial transceiver select. This bit is always 1 with read-only access.
    USBx->GCCFG   |= USB_OTG_GCCFG_PWRDWN; //PWRDWN: Power down Used to activate the transceiver in transmission/reception 0: Power down active 1: Power down deactivated (“Transceiver active”)

    // Disable VBUS sensing (self-powered simplification)
    USBx->GCCFG   |= USB_OTG_GCCFG_NOVBUSSENS; // NOVBUSSENS: VBUS sensing disable option
    USBx->GCCFG   &= ~(USB_OTG_GCCFG_VBUSBSEN | USB_OTG_GCCFG_VBUSASEN); // VBUSBSEN: Enable the VBUS sensing “B” device, VBUSASEN: Enable the VBUS sensing “A” device, 0: VBUS sensing disabled

    // Force device mode
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; // FDMOD: Force device mode, 1: Force device mode
    for (volatile uint32_t i = 0UL; i < 2000UL; ++i) { __NOP(); }

    // Device configuration: Full Speed
    USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DSPD;
    USBx_DEVICE->DCFG |=  USB_OTG_DCFG_DSPD_0; // 01b: Full speed

    // FIFO sizing (units: 32-bit words)
    // RX FIFO: must hold status + setup + data → 128 words is safe
    USBx->GRXFSIZ = 128UL;

    // TX0 (non-periodic, EP0 IN) size = 64 words, start = GRXFSIZ
    USBx->DIEPTXF0_HNPTXFSIZ = (64UL << 16) | 128UL;

    // TX1 (periodic, for EP1 IN) size = 32 words, start = 128 + 64
    USBx->DIEPTXF[0] = (32UL << 16) | (128UL + 64UL);

    // Interrupt mask: reset, RXFLVL, IN/OUT EP
    USBx->GINTMSK  = 0UL;
    USBx->GINTMSK |= USB_OTG_GINTMSK_USBRST;
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
    USBx->GINTMSK |= USB_OTG_GINTMSK_IEPINT;
    USBx->GINTMSK |= USB_OTG_GINTMSK_OEPINT;

    // Global interrupt enable
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;

    // Exit soft-disconnect → enable device pull-up
    USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;

    // NVIC
    NVIC_SetPriority(OTG_FS_IRQn, 1);
    NVIC_EnableIRQ(OTG_FS_IRQn);
}

// ============================
// EP0 init after reset
// ============================

static void ep0_init_after_reset(void)
{
    // EP0 MPS = 64 bytes (encoded 00b → clear the field)
    USBx_OUTEP(0)->DOEPCTL &= ~USB_OTG_DOEPCTL_MPSIZ;
    USBx_INEP(0)->DIEPCTL  &= ~USB_OTG_DIEPCTL_MPSIZ;

    // Unmask EP0 interrupts
    USBx_DEVICE->DAINTMSK = 0UL;
    USBx_DEVICE->DAINTMSK |= (1UL << 0);   // IN EP0
    USBx_DEVICE->DAINTMSK |= (1UL << 16);  // OUT EP0

    // Unmask setup + xfer complete on OUT; xfer complete on IN
    USBx_DEVICE->DOEPMSK  = 0UL;
    USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM;
    USBx_DEVICE->DIEPMSK  = 0UL;
    USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_XFRCM;

    // Arm EP0 OUT to receive a SETUP packet
    USBx_OUTEP(0)->DOEPTSIZ = (1UL << 29) | (3UL << 19) | 8UL; // SUPCNT=1, PKTCNT=1, XFRSIZ=8
    USBx_OUTEP(0)->DOEPCTL  |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_CNAK;

    usb_address_pending = 0U;
    configured = 0U;
}

// ============================
// EP1 IN (HID) configuration (called on SET_CONFIGURATION)
// ============================

static void ep1_in_config(void)
{
    // Clear / set MPSIZ and type
    USBx_INEP(1)->DIEPCTL = 0UL;
    USBx_INEP(1)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
    USBx_INEP(1)->DIEPCTL |= EP1_MPS;             // Max packet size
    USBx_INEP(1)->DIEPCTL |= (3UL << 18);         // EPTYP = Interrupt
    USBx_INEP(1)->DIEPCTL |= (EP1_TX_FIFO_NUM << 22); // TXFNUM = 1 (use TX FIFO #1)
    USBx_INEP(1)->DIEPCTL |= USB_OTG_DIEPCTL_USBAEP;  // Activate endpoint

    // Unmask IN EP1 interrupts (we only care about XFRC)
    USBx_INEP(1)->DIEPINT = 0xFFFFFFFFUL;         // clear any pending
    USBx_DEVICE->DAINTMSK |= (1UL << 1);

    configured = 1U;
}

// ============================
// EP0 helpers (IN data / status stages)
// ============================

static void ep0_tx(const uint8_t *buf, uint16_t len)
{
    // One packet transfer on EP0 IN
    USBx_INEP(0)->DIEPTSIZ = (1UL << 19) | (uint32_t)len; // PKTCNT=1
    USBx_INEP(0)->DIEPCTL  |= USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA;
    usb_write_fifo(0UL, buf, len);
}

static void ep0_status_in(void)
{
    USBx_INEP(0)->DIEPTSIZ = (1UL << 19);                // zero-length packet
    USBx_INEP(0)->DIEPCTL  |= USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA;
}

// ============================
// Descriptor dispatcher (standard requests)
// ============================

static void handle_get_descriptor(uint16_t wValue, uint16_t wIndex, uint16_t wLength)
{
    (void)wIndex;
    const uint8_t *ptr = 0;
    uint16_t len = 0;
    uint8_t dtype  = (uint8_t)(wValue >> 8);
    uint8_t dindex = (uint8_t)(wValue & 0xFFU);

    switch (dtype) {
        case 1:  ptr = dev_desc;           len = (uint16_t)sizeof(dev_desc);        break; // DEVICE
        case 2:  ptr = cfg_desc;           len = (uint16_t)sizeof(cfg_desc);        break; // CONFIG
        case 3:  // STRINGS
            if (dindex == 0U)      { ptr = lang_str; len = (uint16_t)sizeof(lang_str); }
            else if (dindex == 1U) { ptr = mfg_str;  len = (uint16_t)sizeof(mfg_str);  }
            else if (dindex == 2U) { ptr = prod_str; len = (uint16_t)sizeof(prod_str); }
            else if (dindex == 3U) { ptr = sn_str;   len = (uint16_t)sizeof(sn_str);   }
            break;
        case 0x22: ptr = hid_report_desc;  len = (uint16_t)sizeof(hid_report_desc);  break; // HID REPORT
        default:   ptr = 0; break;
    }

    if (ptr == 0) {
        // Stall unsupported descriptor request
        USBx_INEP(0)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
        USBx_OUTEP(0)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
        return;
    }

    if (len > wLength) { len = wLength; }
    ep0_tx(ptr, len);
}

static void handle_standard_request(void)
{
    uint8_t  bmRequestType = ep0_setup[0];
    uint8_t  bRequest      = ep0_setup[1];
    uint16_t wValue        = (uint16_t)(ep0_setup[2] | (ep0_setup[3] << 8));
    uint16_t wIndex        = (uint16_t)(ep0_setup[4] | (ep0_setup[5] << 8));
    uint16_t wLength       = (uint16_t)(ep0_setup[6] | (ep0_setup[7] << 8));
    (void)bmRequestType;
    (void)wIndex;

    switch (bRequest) {
        case 6: // GET_DESCRIPTOR
            handle_get_descriptor(wValue, wIndex, wLength);
            break;

        case 5: // SET_ADDRESS
            usb_address_pending = (uint8_t)(wValue & 0x7FU);
            ep0_status_in(); // apply address after status stage completes
            break;

        case 9: // SET_CONFIGURATION (cfg=1)
            ep1_in_config();
            ep0_status_in();
            break;

        default:
            // Stall unimplemented requests
            USBx_INEP(0)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
            USBx_OUTEP(0)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
            break;
    }

    // Re-arm EP0 OUT for next SETUP packet
    USBx_OUTEP(0)->DOEPTSIZ = (1UL << 29) | (3UL << 19) | 8UL;
    USBx_OUTEP(0)->DOEPCTL  |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_CNAK;
}

// ============================
// USB IRQ handler
// ============================

void OTG_FS_IRQHandler(void)
{
    uint32_t gint = USBx->GINTSTS & USBx->GINTMSK;

    // Bus reset: reinit EP0; clear address
    if ((gint & USB_OTG_GINTSTS_USBRST) != 0UL) {
        USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;  // address = 0
        ep0_init_after_reset();
        USBx->GINTSTS = USB_OTG_GINTSTS_USBRST; // clear
    }

    // RX FIFO non-empty (pop GRXSTSP)
    if ((gint & USB_OTG_GINTSTS_RXFLVL) != 0UL) {
        uint32_t st = USBx->GRXSTSP;
        uint32_t epnum  = (st & USB_OTG_GRXSTSP_EPNUM_Msk) >> USB_OTG_GRXSTSP_EPNUM_Pos;
        uint32_t pktsts = (st & USB_OTG_GRXSTSP_PKTSTS_Msk) >> USB_OTG_GRXSTSP_PKTSTS_Pos;

        if ((epnum == 0UL) && (pktsts == 0x06UL)) { // SETUP packet received
            // Read 8 bytes (2 DWORDs) from FIFO0
            volatile uint32_t *fifo0 = (volatile uint32_t *)(USB_OTG_FIFO_BASE + USB_OTG_FS_PERIPH_BASE + 0UL * 0x1000UL);
            uint32_t w0 = *fifo0;
            uint32_t w1 = *fifo0;
            *(uint32_t *)&ep0_setup[0] = w0;
            *(uint32_t *)&ep0_setup[4] = w1;

            // Handle only standard requests in this minimal example
            handle_standard_request();
        }
    }

    // IN endpoint interrupt(s)
    if ((gint & USB_OTG_GINTSTS_IEPINT) != 0UL) {
        uint32_t daint = USBx_DEVICE->DAINT; // which EP triggered

        // EP0 IN transfer complete: apply pending address after status stage
        if ((daint & (1UL << 0)) != 0UL) {
            uint32_t iepint0 = USBx_INEP(0)->DIEPINT;
            if ((iepint0 & USB_OTG_DIEPINT_XFRC) != 0UL) {
                USBx_INEP(0)->DIEPINT = USB_OTG_DIEPINT_XFRC;
                if (usb_address_pending != 0U) {
                    USBx_DEVICE->DCFG = (USBx_DEVICE->DCFG & ~USB_OTG_DCFG_DAD) |
                                        ((uint32_t)usb_address_pending << 4);
                    usb_address_pending = 0U;
                }
            }
        }

        // EP1 IN transfer complete (we just clear the flag)
        if ((daint & (1UL << 1)) != 0UL) {
            uint32_t iepint1 = USBx_INEP(1)->DIEPINT;
            if ((iepint1 & USB_OTG_DIEPINT_XFRC) != 0UL) {
                USBx_INEP(1)->DIEPINT = USB_OTG_DIEPINT_XFRC;
            }
        }
    }

    // (We don’t use OEPINT in this minimal HID implementation beyond EP0)
}

// ============================
// HID report helpers (send 'a' and release)
// ============================

void usb_hid_send_demo_key_a(void)
{
    if (configured == 0U) return; // only after SET_CONFIGURATION

    static const uint8_t rpt[8] = {
        0x00, // modifiers
        0x00, // reserved
        0x04, // key 'a'
        0x00, 0x00, 0x00, 0x00, 0x00 // remaining keys
    };

    // Program transfer size: 1 packet of 8 bytes
    USBx_INEP(1)->DIEPTSIZ = (1UL << 19) | (uint32_t)sizeof(rpt); // PKTCNT=1, XFRSIZ=8
    // Clear NAK & enable EP1 IN
    USBx_INEP(1)->DIEPCTL  |= USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA;
    // Write report to TX FIFO #1
    usb_write_fifo(1UL, rpt, (uint16_t)sizeof(rpt));
}

void usb_hid_send_key_release(void)
{
    if (configured == 0U) return;

    static const uint8_t rpt0[8] = {0,0,0,0,0,0,0,0};

    USBx_INEP(1)->DIEPTSIZ = (1UL << 19) | (uint32_t)sizeof(rpt0); // PKTCNT=1
    USBx_INEP(1)->DIEPCTL  |= USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA;
    usb_write_fifo(1UL, rpt0, (uint16_t)sizeof(rpt0));
}
